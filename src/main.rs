#![feature(inherent_associated_types)]

use axum::{response::IntoResponse, routing::post, Extension, Router};
use futures::{future, StreamExt};
use tarpc::{
    context, server,
    server::{incoming::Incoming, Channel},
    tokio_serde::formats::Json,
};

use std::{net::SocketAddr, sync::Arc};

use tokio::{select, sync::Mutex};

mod paxos;

use paxos::{
    AcceptRequest, AcceptResponse, AcceptorService, Paxos, PrepareRequest, PrepareResponse,
};

#[derive(Clone)]

struct AcceptorServer {
    paxos: Arc<Mutex<Paxos>>,
}

impl AcceptorServer {
    fn new(paxos: Arc<Mutex<Paxos>>) -> Self {
        Self { paxos }
    }
}

#[tarpc::server]
impl AcceptorService for AcceptorServer {
    async fn prepare(
        self,
        _: context::Context,
        request: PrepareRequest,
    ) -> Result<PrepareResponse, String> {
        let mut acceptor = self.paxos.lock().await;

        acceptor
            .on_prepare(request)
            .await
            .map_err(|err| err.to_string())
    }

    async fn accept(
        self,
        _: context::Context,
        request: AcceptRequest,
    ) -> Result<AcceptResponse, String> {
        let mut acceptor = self.paxos.lock().await;

        acceptor
            .on_accept(request)
            .await
            .map_err(|err| err.to_string())
    }
}

#[tokio::main]
async fn main() {
    let id: u32 = std::env::var("ID")
        .expect("ID env variable is required")
        .parse()
        .expect("ID must be an integer");

    assert!(id > 0 && id <= 3, "id must be between 0 and 3");

    let http_server_addr: SocketAddr = format!("0.0.0.0:300{id}").parse().unwrap();

    let rpc_server_addr: SocketAddr = format!("127.0.0.1:800{id}")
        .parse()
        .expect("invalid socket addr");

    let acceptors = (1..=3)
        .map(|id| format!("127.0.0.1:800{id}").parse().unwrap())
        .collect();

    let paxos = Arc::new(Mutex::new(
        Paxos::new(id, rpc_server_addr, acceptors)
            .await
            .expect("instantiating paxos instance"),
    ));

    let app = Router::new()
        .route("/", post(propose))
        .layer(Extension(Arc::clone(&paxos)));

    println!("starting http server on {http_server_addr}");
    println!("starting rpc server on {rpc_server_addr}");

    select! {
      err =  axum::Server::bind(&http_server_addr).serve(app.into_make_service()) => {
        panic!("http server exited: err={err:?}");
      }
      _ = async {
        let mut listener = tarpc::serde_transport::tcp::listen(&rpc_server_addr, Json::default)
        .await
        .expect("listening on server addr");

        listener.config_mut().max_frame_length(usize::MAX);

        listener
        // Ignore accept errors.
        .filter_map(|r| future::ready(r.ok()))
        .map(server::BaseChannel::with_defaults)
        // Limit channels to 1 per IP.
        .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
        // serve is generated by the service attribute. It takes as input any type implementing
        // the generated World trait.
        .map(|channel| {
            let server = AcceptorServer::new(Arc::clone(&paxos));
            channel.execute(server.serve())
        })
        // Max 10 channels.
        .buffer_unordered(10)
        .for_each(|_| async {})
        .await;
      } => {
        panic!("rpc server exited");
      }
    };
}

async fn propose(
    Extension(paxos): Extension<Arc<Mutex<Paxos>>>,
    value: String,
) -> impl IntoResponse {
    let mut paxos = paxos.lock().await;

    match paxos.propose(value.into_bytes()).await {
        Err(err) => err.to_string(),
        Ok(()) => "value accepted".to_owned(),
    }
}
